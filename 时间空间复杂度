算法及时间复杂度总结：
	1. 二分法 倍增法 快速幂 辗转相除法  O(logn)
	2. 枚举 双指针 单调栈算法 KMP RabinKarp Manacher’s  O(n)
	3. 快排 归并排序 堆排序 O(nlogn）
	4. 枚举 动态规划 Dijkstra O(n^2)
	5. 枚举 动态规划 Floyd O(n^3)
	6. 组合相关的搜索  O(2^n)
	7. 排列有关的搜索  O(n!)
	
######################################################################################################	
时间复杂度练习：
1. 
	int Fibo(int n) {
		if (n == 0 || n == 1) return 1;
		return Fibo(n - 1) + Fibo(n - 2);
	}
	时间复杂度上界：Fibo(n) = Fibo(n-1) + Fibo(n-2) < 2 * Fibo(n-1)
	             T(n) = 2 * T(n-1) + O(1) = O(2^n)
	时间复杂度下界：Fibo(n) = Fibo(n-1) + Fibo(n-2) > 2 * Fibo(n-2)
                 T(n) = 2 * T(n-2) + O(1) = O(2^(n/2))
 ----------------------------------------------------------------------------------------------------
2. 
	int[] F = new int[50];
	F[0] = F[1] = 1;
	...
	int Fibo(int n) {
		if (F[n] != 0) return F[n];
		F[n] = Fibo(n-1) + Fibo(n-2);
		return F[n];
	}
    这个题的陷阱就是，在你算完Fibo(n-1) 之后，Fibo(n-2)的值已经被存到数组之中了，避免了重复运算
	T(n) =T(n-1) + O(1)=O(n)
----------------------------------------------------------------------------------------------------
3. 
	int j = 0;
	for (int i = 0; i < n; i++) {
		while (j < n && nums[j] - nums[i] < window) {
			j++;
		}
	}
	这个程序是典型的双指针算法，[i, j) 是一个滑动窗口的两端，滑动窗口之内的数，两两之差 < window。
    时间复杂度的定义，是程序总共执行的语句数目的数量级。在这个代码中，执行次数最多的是 j++ 这个循环主体。
	j一直是自顾自的单向递增，那么一旦某一次 while 循环使得 j++ 执行了 n 次以后，while 循环就再也进不去了。
	因此总共的执行次数是 O(n + n) = O(n)O(n+n)=O(n) 而不是 O(n * n)O(n∗n)。
######################################################################################################	
空间复杂度
	1.空间复杂度只考虑运行时临时占用的空间，又称为算法的额外空间
	2.临时占用的空间:
		1. 为参数列表中形参变量分配的空间
		2. 为函数体中局部变量分配的空间
		3. 递归函数，需要将上述两部分占用空间的和乘以递归的深度，这是堆栈空间
	3. 在递归函数中，除了变量和数组所开辟的临时空间以外，还有一个空间我们需要纳入考虑，就是递归时占用的栈空间
	   递归函数需要保存当前的环境，以便在递归返回的时候能够还原之前的现场。因此递归的深度越深，所要占用的栈空间越大。
	   当空间超出一定范围的时候就会出现程序爆栈（Stack Overflow）的情况。
