算法及时间复杂度总结：
	1. 二分法 倍增法 快速幂 辗转相除法  O(logn)
	2. 枚举 双指针 单调栈算法 KMP RabinKarp Manacher’s  O(n)
	3. 快排 归并排序 堆排序 O(nlogn）
	4. 枚举 动态规划 Dijkstra O(n^2)
	5. 枚举 动态规划 Floyd O(n^3)
	6. 组合相关的搜索  O(2^n)
	7. 排列有关的搜索  O(n!)
	
######################################################################################################	
时间复杂度练习：
1. 
	int Fibo(int n) {
		if (n == 0 || n == 1) return 1;
		return Fibo(n - 1) + Fibo(n - 2);
	}
	时间复杂度上界：Fibo(n) = Fibo(n-1) + Fibo(n-2) < 2 * Fibo(n-1)
	             T(n) = 2 * T(n-1) + O(1) = O(2^n)
	时间复杂度下界：Fibo(n) = Fibo(n-1) + Fibo(n-2) > 2 * Fibo(n-2)
                 T(n) = 2 * T(n-2) + O(1) = O(2^(n/2))
 ----------------------------------------------------------------------------------------------------
2. 
	int[] F = new int[50];
	F[0] = F[1] = 1;
	...
	int Fibo(int n) {
		if (F[n] != 0) return F[n];
		F[n] = Fibo(n-1) + Fibo(n-2);
		return F[n];
	}
    这个题的陷阱就是，在你算完Fibo(n-1) 之后，Fibo(n-2)的值已经被存到数组之中了，避免了重复运算
	T(n) =T(n-1) + O(1)=O(n)
----------------------------------------------------------------------------------------------------
3. 
	int j = 0;
	for (int i = 0; i < n; i++) {
		while (j < n && nums[j] - nums[i] < window) {
			j++;
		}
	}
	这个程序是典型的双指针算法，[i, j) 是一个滑动窗口的两端，滑动窗口之内的数，两两之差 < window。
    时间复杂度的定义，是程序总共执行的语句数目的数量级。在这个代码中，执行次数最多的是 j++ 这个循环主体。
	j一直是自顾自的单向递增，那么一旦某一次 while 循环使得 j++ 执行了 n 次以后，while 循环就再也进不去了。
	因此总共的执行次数是 O(n + n) = O(n)O(n+n)=O(n) 而不是 O(n * n)O(n∗n)。
######################################################################################################	
空间复杂度
	1.空间复杂度只考虑运行时临时占用的空间，又称为算法的额外空间
	2.临时占用的空间:
		1. 为参数列表中形参变量分配的空间
		2. 为函数体中局部变量分配的空间
		3. 递归函数，需要将上述两部分占用空间的和乘以递归的深度，这是堆栈空间
	3. 在递归函数中，除了变量和数组所开辟的临时空间以外，还有一个空间我们需要纳入考虑，就是递归时占用的栈空间
	   递归函数需要保存当前的环境，以便在递归返回的时候能够还原之前的现场。因此递归的深度越深，所要占用的栈空间越大。
	   当空间超出一定范围的时候就会出现程序爆栈（Stack Overflow）的情况。
######################################################################################################	
内存空间
	1. 两个部分： 栈空间stack space 和 堆空间heap space
	2. 栈空间
		1. 当一个程序在执行的时候，操作系统为了让进程可以使用一些固定的不被其他进程侵占的空间用于进行函数调用，递归等操作，
		   会开辟一个固定大小的空间（比如 8M）给一个进程使用。这个空间不会太大，否则内存的利用率就很低。
	        2. 栈溢出（Stack Overflow）是指在函数调用，或者递归调用的时候，开辟了过多的内存，超过了操作系统余留的那个很小的固定空间导致的。
		3. 包括的内容
			1. 函数的参数和返回值
			2. 函数的局部变量 
		4. int[] nums=new int[20] 
			1. nums是一个局部变量，是一个地址，指向内存空间， 存放在在栈空间
			2. new出来的 是存放20个整数的数组 ，这部分在对堆空间里
		5. 栈空间里的内容会在函数执行结束之后被撤回 
	3. 区分栈空间和堆空间：new 出来的都在堆空间里 其他都在栈空间

	
	   
	   
